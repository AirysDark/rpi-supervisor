#!/usr/bin/env python3
"""
Rpi Supervisor — Storage Hardener

Safely hardens the root filesystem mount options to reduce SD corruption.

Features:
- Auto-detect root device
- Supports PARTUUID entries
- Verify ext4
- Preserve existing mount flags
- Remove old commit values
- Inject safe options
- Atomic fstab write
- Create timestamp backup
- Idempotent (safe to re-run)
- RO-root friendly

Binary name: rsup-storage-harden
"""

import subprocess
import shutil
import time
import re
from pathlib import Path
import sys
import tempfile

FSTAB = Path("/etc/fstab")

REQUIRED_FLAGS = [
    "noatime",
    "errors=remount-ro",
]

COMMIT_VALUE = "commit=30"

ROOT_MOUNTPOINT = "/"


# ============================================================
# Logging
# ============================================================

def log(msg: str):
    print(f"[rsup-storage] {msg}", flush=True)


# ============================================================
# Shell helpers
# ============================================================

def run(cmd):
    return subprocess.check_output(cmd, text=True).strip()


# ============================================================
# Root detection
# ============================================================

def get_root_info():
    """
    Returns (source, fstype)
    Example source:
      /dev/mmcblk0p2
      PARTUUID=xxxx
    """
    root_dev = run(["findmnt", "-n", "-o", "SOURCE", "/"])
    root_fs = run(["findmnt", "-n", "-o", "FSTYPE", "/"])
    return root_dev, root_fs


# ============================================================
# Backup
# ============================================================

def backup_fstab():
    ts = int(time.time())
    backup = FSTAB.with_name(f"fstab.bak.{ts}")
    shutil.copy2(FSTAB, backup)
    log(f"Backup created: {backup}")


# ============================================================
# Option normalization
# ============================================================

def normalize_opts(opts: str) -> str:
    parts = [o.strip() for o in opts.split(",") if o.strip()]

    # Remove old commit values
    parts = [p for p in parts if not p.startswith("commit=")]

    # Ensure required flags
    for flag in REQUIRED_FLAGS:
        if flag not in parts:
            parts.append(flag)

    # Add commit value
    if COMMIT_VALUE not in parts:
        parts.append(COMMIT_VALUE)

    # Deduplicate while preserving order
    seen = set()
    cleaned = []
    for p in parts:
        if p not in seen:
            seen.add(p)
            cleaned.append(p)

    return ",".join(cleaned)


# ============================================================
# Root line detection
# ============================================================

def is_root_entry(parts):
    """
    Determine if this fstab entry is the root mount.
    Works with:
      /dev/*
      PARTUUID=*
      UUID=*
    """
    if len(parts) < 4:
        return False

    mountpoint = parts[1]
    return mountpoint == ROOT_MOUNTPOINT


# ============================================================
# Atomic write
# ============================================================

def atomic_write(path: Path, content: str):
    with tempfile.NamedTemporaryFile(
        "w",
        delete=False,
        dir=str(path.parent)
    ) as tmp:
        tmp.write(content)
        temp_name = tmp.name

    Path(temp_name).replace(path)


# ============================================================
# Main
# ============================================================

def main():
    log("Detecting root filesystem...")

    try:
        root_dev, root_fs = get_root_info()
    except Exception as e:
        log(f"Failed to detect root: {e}")
        return 1

    log(f"Root device: {root_dev}")
    log(f"Filesystem: {root_fs}")

    if root_fs != "ext4":
        log("Filesystem is not ext4 — skipping")
        return 0

    if not FSTAB.exists():
        log("fstab missing — abort")
        return 1

    lines = FSTAB.read_text().splitlines()
    new_lines = []
    modified = False

    for line in lines:
        stripped = line.strip()

        # Preserve comments and blanks
        if not stripped or stripped.startswith("#"):
            new_lines.append(line)
            continue

        parts = line.split()

        if is_root_entry(parts):
            old_opts = parts[3]
            new_opts = normalize_opts(old_opts)

            if new_opts != old_opts:
                log("Updating root mount options")
                log(f"  old: {old_opts}")
                log(f"  new: {new_opts}")
                parts[3] = new_opts
                modified = True

            new_lines.append("\t".join(parts))
        else:
            new_lines.append(line)

    if not modified:
        log("fstab already optimal — no changes")
        return 0

    # Backup only if changing
    backup_fstab()

    # Atomic write
    atomic_write(FSTAB, "\n".join(new_lines) + "\n")

    log("fstab updated successfully")
    log("Reboot recommended")

    return 0


if __name__ == "__main__":
    sys.exit(main())