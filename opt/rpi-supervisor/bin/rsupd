#!/usr/bin/env python3
"""
Rpi Supervisor Daemon (rsupd) — Elite Production Version
GPIO priority:
1) /boot config.txt overlays
2) supervisor.conf
3) hard defaults
"""

import os
import time
import subprocess
import threading
import configparser
import re
from pathlib import Path
from gpiozero import Button, OutputDevice
from signal import pause

# ============================================================
# BOOT CONFIG DETECTION
# ============================================================

BOOTCFG = Path("/boot/config.txt")
if Path("/boot/firmware/config.txt").exists():
    BOOTCFG = Path("/boot/firmware/config.txt")

# ============================================================
# OPTIONAL WATCHDOG MODULE
# ============================================================

try:
    from rpi_supervisor import watchdog
    WATCHDOG_AVAILABLE = True
except Exception:
    WATCHDOG_AVAILABLE = False

# ============================================================
# CONFIG LOADER
# ============================================================

CONFIG_PATH = "/etc/rpi-supervisor/supervisor.conf"

cfg = configparser.ConfigParser()
cfg.read(CONFIG_PATH)


def cfg_get(section, key, fallback):
    try:
        if isinstance(fallback, bool):
            return cfg.getboolean(section, key, fallback=fallback)
        if isinstance(fallback, int):
            return cfg.getint(section, key, fallback=fallback)
        if isinstance(fallback, float):
            return cfg.getfloat(section, key, fallback=fallback)
        return cfg.get(section, key, fallback=fallback)
    except Exception:
        return fallback


# ============================================================
# BOOT CONFIG PARSER
# ============================================================

def read_boot_config():
    if not BOOTCFG.exists():
        return ""

    try:
        return BOOTCFG.read_text()
    except Exception:
        return ""


BOOT_TEXT = read_boot_config()


def extract_overlay_pin(name, pattern):
    """
    Extract GPIO pin from overlay line.
    Example:
      dtoverlay=gpio-shutdown,gpio_pin=17
      dtoverlay=gpio-safepower,gpiopin=22
    """
    match = re.search(pattern, BOOT_TEXT)
    if match:
        return int(match.group(1))
    return None


def get_shutdown_pin():
    pin = extract_overlay_pin(
        "gpio-shutdown",
        r"dtoverlay=gpio-shutdown.*gpio_pin=(\d+)"
    )
    if pin is not None:
        return pin
    return cfg_get("gpio", "shutdown_pin", 17)


def get_safepower_pin():
    pin = extract_overlay_pin(
        "gpio-safepower",
        r"dtoverlay=gpio-safepower.*gpiopin=(\d+)"
    )
    if pin is not None:
        return pin
    return cfg_get("gpio", "safepower_pin", 22)


def get_powerfail_pin():
    pin = extract_overlay_pin(
        "gpio-powerfail",
        r"dtoverlay=gpio-powerfail.*gpio_pin=(\d+)"
    )
    if pin is not None:
        return pin
    return cfg_get("gpio", "power_fail_pin", 23)


# ============================================================
# FINAL GPIO VALUES (Priority Applied)
# ============================================================

SHUTDOWN_PIN = get_shutdown_pin()
SAFEPOWER_PIN = get_safepower_pin()
POWER_FAIL_PIN = get_powerfail_pin()

RESET_PIN = cfg_get("gpio", "reset_pin", 27)

ENABLE_POWER_FAIL = cfg_get("gpio", "enable_power_fail", False)

BOOT_IGNORE_TIME = cfg_get("core", "boot_ignore_time", 5.0)
BOUNCE_TIME = cfg_get("gpio", "bounce_time", 0.05)

SHUTDOWN_SCRIPT = "/opt/rpi-supervisor/bin/rsup-shutdown"
RESTART_SCRIPT = "/opt/rpi-supervisor/bin/rsup-reboot"
RO_ENFORCE_SCRIPT = "/opt/rpi-supervisor/bin/rsup-enable-ro-root"

CLEAN_FLAG = Path("/run/rpi-supervisor/clean-shutdown.flag")

BROWNOUT_CHECK_INTERVAL = cfg_get("brownout", "check_interval", 5.0)
BROWNOUT_TRIGGER_COUNT = cfg_get("brownout", "trigger_count", 3)
BROWNOUT_SHUTDOWN = cfg_get("brownout", "shutdown_on_trigger", True)

WATCHDOG_INTERVAL = cfg_get("watchdog", "interval", 20)

# ============================================================
# STATE
# ============================================================

boot_time = time.time()
shutdown_triggered = False
shutdown_lock = threading.Lock()
brownout_counter = 0
ro_check_done = False

# ============================================================
# SAFE POWER OUTPUT
# ============================================================

safe_out = OutputDevice(
    SAFEPOWER_PIN,
    active_high=True,
    initial_value=False
)

# ============================================================
# LOG
# ============================================================

def log(msg: str):
    print(f"[rsupd] {msg}", flush=True)


log(f"GPIO configuration:")
log(f"  Shutdown  : {SHUTDOWN_PIN}")
log(f"  SafePower : {SAFEPOWER_PIN}")
log(f"  PowerFail : {POWER_FAIL_PIN}")
log(f"  Reset     : {RESET_PIN}")

# ============================================================
# SCRIPT EXECUTOR
# ============================================================

def run_script(path: str):
    if not os.path.exists(path):
        log(f"Missing script: {path}")
        return
    if not os.access(path, os.X_OK):
        log(f"Not executable: {path}")
        return

    try:
        subprocess.Popen(
            [path],
            stdout=subprocess.DEVNULL,
            stderr=subprocess.DEVNULL,
            start_new_session=True,
        )
    except Exception as e:
        log(f"Execution failed: {e}")


def mark_clean_shutdown():
    try:
        CLEAN_FLAG.parent.mkdir(parents=True, exist_ok=True)
        CLEAN_FLAG.touch(exist_ok=True)
    except Exception:
        pass


# ============================================================
# POWER ACTIONS
# ============================================================

def safe_shutdown(reason="unknown"):
    global shutdown_triggered

    with shutdown_lock:
        if shutdown_triggered:
            return
        shutdown_triggered = True

    log(f"Shutdown initiated ({reason})")

    try:
        safe_out.on()
        if WATCHDOG_AVAILABLE:
            watchdog.set_safe_power(True)
    except Exception:
        pass

    mark_clean_shutdown()
    run_script(SHUTDOWN_SCRIPT)


def safe_reboot():
    log("Reset button pressed")
    mark_clean_shutdown()
    run_script(RESTART_SCRIPT)


# ============================================================
# BROWNOUT MONITOR
# ============================================================

def check_undervoltage():
    try:
        out = subprocess.check_output(
            ["vcgencmd", "get_throttled"],
            text=True,
            timeout=2,
        ).strip()

        if "=" not in out:
            return False

        value = int(out.split("=")[1], 16)
        return bool(value & 0x1)

    except Exception:
        return False


def brownout_monitor():
    global brownout_counter

    log("Brownout monitor started")

    while True:
        time.sleep(BROWNOUT_CHECK_INTERVAL)

        if shutdown_triggered:
            continue

        if check_undervoltage():
            brownout_counter += 1
            log(f"Undervoltage detected ({brownout_counter})")

            if (
                BROWNOUT_SHUTDOWN
                and brownout_counter >= BROWNOUT_TRIGGER_COUNT
            ):
                safe_shutdown("brownout")
        else:
            brownout_counter = 0


# ============================================================
# OPTIONAL POWER FAIL INPUT
# ============================================================

if ENABLE_POWER_FAIL:
    power_fail_in = Button(
        POWER_FAIL_PIN,
        pull_up=True,
        bounce_time=0.02,
    )

    def power_fail_triggered():
        if time.time() - boot_time < BOOT_IGNORE_TIME:
            return
        if shutdown_triggered:
            return
        safe_shutdown("power-fail")

    power_fail_in.when_released = power_fail_triggered
    log("Power-fail hold-up ENABLED")

# ============================================================
# GPIO BUTTONS
# ============================================================

shutdown_sw = Button(
    SHUTDOWN_PIN,
    pull_up=True,
    bounce_time=BOUNCE_TIME,
)

reset_btn = Button(
    RESET_PIN,
    pull_up=True,
    bounce_time=BOUNCE_TIME,
)

def shutdown_edge():
    if time.time() - boot_time < BOOT_IGNORE_TIME:
        return
    if shutdown_triggered:
        return
    if shutdown_sw.is_pressed:
        safe_shutdown("switch")

shutdown_sw.when_pressed = shutdown_edge
reset_btn.when_pressed = safe_reboot

# ============================================================
# SYSTEMD WATCHDOG
# ============================================================

try:
    import sdnotify
    notifier = sdnotify.SystemdNotifier()
    SYSTEMD_NOTIFY = True
except Exception:
    SYSTEMD_NOTIFY = False
    notifier = None


def watchdog_ping():
    if not SYSTEMD_NOTIFY:
        return

    log("systemd watchdog enabled")

    while True:
        notifier.notify("WATCHDOG=1")
        time.sleep(WATCHDOG_INTERVAL)


# ============================================================
# STARTUP
# ============================================================

if WATCHDOG_AVAILABLE:
    watchdog.start_background_thread()
    watchdog.mark_event("running")

threading.Thread(target=brownout_monitor, daemon=True).start()
threading.Thread(target=watchdog_ping, daemon=True).start()

if SYSTEMD_NOTIFY:
    notifier.notify("READY=1")

log("Rpi Supervisor started — SAFE=LOW (running)")

pause()