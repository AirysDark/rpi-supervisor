#!/usr/bin/env python3
"""
Rpi Supervisor Daemon (rsupd) — Elite Production Version
"""

import os
import time
import subprocess
import threading
import configparser
from pathlib import Path
from gpiozero import Button, OutputDevice
from signal import pause

# ============================================================
# OPTIONAL WATCHDOG MODULE
# ============================================================

try:
    from rpi_supervisor import watchdog
    WATCHDOG_AVAILABLE = True
except Exception:
    WATCHDOG_AVAILABLE = False

# ============================================================
# CONFIG LOADER
# ============================================================

CONFIG_PATH = "/etc/rpi-supervisor/supervisor.conf"

cfg = configparser.ConfigParser()
cfg.read(CONFIG_PATH)


def cfg_get(section, key, fallback):
    try:
        if isinstance(fallback, bool):
            return cfg.getboolean(section, key, fallback=fallback)
        if isinstance(fallback, int):
            return cfg.getint(section, key, fallback=fallback)
        if isinstance(fallback, float):
            return cfg.getfloat(section, key, fallback=fallback)
        return cfg.get(section, key, fallback=fallback)
    except Exception:
        return fallback


# ============================================================
# systemd watchdog support
# ============================================================

try:
    import sdnotify
    notifier = sdnotify.SystemdNotifier()
    SYSTEMD_NOTIFY = True
except Exception:
    notifier = None
    SYSTEMD_NOTIFY = False

# ============================================================
# CONFIG
# ============================================================

SHUTDOWN_PIN = cfg_get("gpio", "shutdown_pin", 17)
RESET_PIN = cfg_get("gpio", "reset_pin", 27)
SAFEPOWER_PIN = cfg_get("gpio", "safepower_pin", 22)

ENABLE_POWER_FAIL = cfg_get("gpio", "enable_power_fail", False)
POWER_FAIL_PIN = cfg_get("gpio", "power_fail_pin", 23)

BOOT_IGNORE_TIME = cfg_get("core", "boot_ignore_time", 5.0)
BOUNCE_TIME = cfg_get("gpio", "bounce_time", 0.05)

SHUTDOWN_SCRIPT = "/opt/rpi-supervisor/bin/rsup-shutdown"
RESTART_SCRIPT = "/opt/rpi-supervisor/bin/rsup-reboot"
RO_ENFORCE_SCRIPT = "/opt/rpi-supervisor/bin/rsup-enable-ro-root"

# fallback marker (systemd service should be primary writer)
CLEAN_FLAG = Path("/run/rpi-supervisor/clean-shutdown.flag")

BROWNOUT_CHECK_INTERVAL = cfg_get("brownout", "check_interval", 5.0)
BROWNOUT_TRIGGER_COUNT = cfg_get("brownout", "trigger_count", 3)
BROWNOUT_SHUTDOWN = cfg_get("brownout", "shutdown_on_trigger", True)

WATCHDOG_INTERVAL = cfg_get("watchdog", "interval", 20)

# ============================================================
# STATE
# ============================================================

boot_time = time.time()
shutdown_triggered = False
shutdown_lock = threading.Lock()
brownout_counter = 0
ro_check_done = False

# ============================================================
# SAFE POWER SIGNAL
# ============================================================

safe_out = OutputDevice(
    SAFEPOWER_PIN,
    active_high=True,
    initial_value=False  # LOW = running
)

# ============================================================
# HELPERS
# ============================================================


def log(msg: str):
    print(f"[rsupd] {msg}", flush=True)


def run_script(path: str):
    """Safely execute helper script."""
    if not os.path.exists(path):
        log(f"Missing script: {path}")
        return

    if not os.access(path, os.X_OK):
        log(f"Not executable: {path}")
        return

    try:
        subprocess.Popen(
            [path],
            stdout=subprocess.DEVNULL,
            stderr=subprocess.DEVNULL,
            start_new_session=True,
        )
    except Exception as e:
        log(f"Failed to execute {path}: {e}")


def mark_clean_shutdown():
    """
    Fallback only.
    Primary clean marker should come from systemd service.
    """
    try:
        CLEAN_FLAG.parent.mkdir(parents=True, exist_ok=True)
        CLEAN_FLAG.touch(exist_ok=True)
    except Exception:
        pass


# ============================================================
# READ-ONLY ROOT ENFORCER
# ============================================================

def root_is_read_only() -> bool:
    try:
        out = subprocess.check_output(
            ["findmnt", "-n", "-o", "OPTIONS", "/"],
            text=True,
            timeout=2,
        )
        return "ro" in out.split(",")
    except Exception:
        return False


def enforce_ro_root_once():
    global ro_check_done

    if ro_check_done:
        return
    ro_check_done = True

    try:
        if root_is_read_only():
            log("RO root already active")
            return

        if not os.path.exists(RO_ENFORCE_SCRIPT):
            log("RO enforcement script missing")
            return

        log("Root is RW — enabling RO mode")

        subprocess.Popen(
            [RO_ENFORCE_SCRIPT],
            stdout=subprocess.DEVNULL,
            stderr=subprocess.DEVNULL,
            start_new_session=True,
        )

    except Exception as e:
        log(f"RO check failed: {e}")


# ============================================================
# POWER ACTIONS
# ============================================================

def safe_shutdown(reason="unknown"):
    global shutdown_triggered

    with shutdown_lock:
        if shutdown_triggered:
            return
        shutdown_triggered = True

    log(f"Shutdown initiated ({reason})")

    try:
        safe_out.on()
        if WATCHDOG_AVAILABLE:
            watchdog.set_safe_power(True)
    except Exception:
        pass

    # fallback only
    mark_clean_shutdown()

    run_script(SHUTDOWN_SCRIPT)


def safe_reboot():
    log("Reset button pressed")
    mark_clean_shutdown()
    run_script(RESTART_SCRIPT)


# ============================================================
# BROWNOUT MONITOR
# ============================================================

def check_undervoltage():
    try:
        out = subprocess.check_output(
            ["vcgencmd", "get_throttled"],
            text=True,
            timeout=2,
        ).strip()

        if "=" not in out:
            return False

        value = int(out.split("=")[1], 16)
        return bool(value & 0x1)

    except Exception as e:
        log(f"vcgencmd error: {e}")
        return False


def brownout_monitor():
    global brownout_counter

    log("Brownout monitor started")

    while True:
        time.sleep(BROWNOUT_CHECK_INTERVAL)

        if shutdown_triggered:
            continue

        if check_undervoltage():
            brownout_counter += 1
            log(f"Undervoltage detected ({brownout_counter})")

            if (
                BROWNOUT_SHUTDOWN
                and brownout_counter >= BROWNOUT_TRIGGER_COUNT
            ):
                log("Brownout threshold reached — shutting down")
                safe_shutdown("brownout")
        else:
            brownout_counter = 0


# ============================================================
# OPTIONAL POWER-FAIL
# ============================================================

if ENABLE_POWER_FAIL:
    power_fail_in = Button(
        POWER_FAIL_PIN,
        pull_up=True,
        bounce_time=0.02,
    )

    def power_fail_triggered():
        if time.time() - boot_time < BOOT_IGNORE_TIME:
            return
        if shutdown_triggered:
            return

        log("POWER FAIL detected — initiating hold-up shutdown")
        safe_shutdown("power-fail")

    power_fail_in.when_released = power_fail_triggered
    log("Power-fail hold-up ENABLED")

# ============================================================
# GPIO BUTTONS
# ============================================================

shutdown_sw = Button(
    SHUTDOWN_PIN,
    pull_up=True,
    bounce_time=BOUNCE_TIME,
)

reset_btn = Button(
    RESET_PIN,
    pull_up=True,
    bounce_time=BOUNCE_TIME,
)


def shutdown_edge():
    if time.time() - boot_time < BOOT_IGNORE_TIME:
        log("Ignoring switch during boot window")
        return
    if shutdown_triggered:
        return
    if shutdown_sw.is_pressed:
        safe_shutdown("switch")


shutdown_sw.when_pressed = shutdown_edge
reset_btn.when_pressed = safe_reboot

# ============================================================
# SYSTEMD WATCHDOG THREAD
# ============================================================

def watchdog_ping():
    if not SYSTEMD_NOTIFY:
        return

    log("systemd watchdog enabled")

    while True:
        notifier.notify("WATCHDOG=1")
        time.sleep(WATCHDOG_INTERVAL)


# ============================================================
# STARTUP
# ============================================================

if WATCHDOG_AVAILABLE:
    watchdog.start_background_thread()
    watchdog.mark_event("running")

threading.Thread(target=brownout_monitor, daemon=True).start()
threading.Thread(target=watchdog_ping, daemon=True).start()

threading.Timer(10, enforce_ro_root_once).start()

if SYSTEMD_NOTIFY:
    notifier.notify("READY=1")

log("Rpi Supervisor started — SAFE=LOW (running)")

pause()