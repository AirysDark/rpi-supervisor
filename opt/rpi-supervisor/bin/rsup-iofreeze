#!/usr/bin/env python3
"""
Rpi Supervisor — I/O Freeze Helper (Production Hardened)

Purpose:
Temporarily freeze critical filesystems during shutdown
to reduce corruption risk.

Safety guarantees:
- Never blocks shutdown
- Safe if fsfreeze missing
- Safe on read-only root
- Timeout protected
- Idempotent
- Parallel-safe
- Works on Pi 3/4/5
"""

import subprocess
import shutil
import time
import sys
from pathlib import Path

# ============================================================
# CONFIG
# ============================================================

FREEZE_TARGETS = [
    "/",  # root filesystem
]

FREEZE_HOLD_SECONDS = 1
FSFREEZE_TIMEOUT = 3

LOCK_FILE = Path("/run/rpi-supervisor/iofreeze.lock")

# ============================================================
# HELPERS
# ============================================================

def log(msg: str):
    print(f"[rsup-iofreeze] {msg}", flush=True)


def has_fsfreeze() -> bool:
    return shutil.which("fsfreeze") is not None


def is_mountpoint(path: str) -> bool:
    result = subprocess.run(
        ["mountpoint", "-q", path],
        stdout=subprocess.DEVNULL,
        stderr=subprocess.DEVNULL,
    )
    return result.returncode == 0


def is_read_only(path: str) -> bool:
    try:
        out = subprocess.check_output(
            ["findmnt", "-n", "-o", "OPTIONS", path],
            text=True,
            timeout=2,
        )
        return "ro" in out.split(",")
    except Exception:
        return False


def is_already_frozen(path: str) -> bool:
    """
    Best-effort detection.
    fsfreeze has no clean query, so we probe safely.
    """
    try:
        # Try harmless sync inside a timeout
        subprocess.run(
            ["sync"],
            timeout=1,
            stdout=subprocess.DEVNULL,
            stderr=subprocess.DEVNULL,
        )
        return False
    except Exception:
        return True


def freeze_mount(path: str):
    if not is_mountpoint(path):
        log(f"Skip (not mountpoint): {path}")
        return

    if is_read_only(path):
        log(f"Skip (already read-only): {path}")
        return

    if is_already_frozen(path):
        log(f"Skip (already frozen): {path}")
        return

    try:
        subprocess.run(
            ["fsfreeze", "-f", path],
            timeout=FSFREEZE_TIMEOUT,
            stdout=subprocess.DEVNULL,
            stderr=subprocess.DEVNULL,
            check=False,
        )
        log(f"Frozen: {path}")
    except subprocess.TimeoutExpired:
        log(f"Freeze timeout: {path}")
    except Exception as e:
        log(f"Freeze error {path}: {e}")


def unfreeze_mount(path: str):
    if not is_mountpoint(path):
        return

    try:
        subprocess.run(
            ["fsfreeze", "-u", path],
            timeout=FSFREEZE_TIMEOUT,
            stdout=subprocess.DEVNULL,
            stderr=subprocess.DEVNULL,
            check=False,
        )
        log(f"Unfrozen: {path}")
    except subprocess.TimeoutExpired:
        log(f"Unfreeze timeout: {path}")
    except Exception as e:
        log(f"Unfreeze error {path}: {e}")


# ============================================================
# LOCKING (parallel safety)
# ============================================================

def acquire_lock() -> bool:
    try:
        LOCK_FILE.parent.mkdir(parents=True, exist_ok=True)
        LOCK_FILE.touch(exist_ok=False)
        return True
    except FileExistsError:
        log("Another freeze already running — skipping")
        return False
    except Exception:
        return False


def release_lock():
    try:
        LOCK_FILE.unlink(missing_ok=True)
    except Exception:
        pass


# ============================================================
# MAIN
# ============================================================

def main():
    if not has_fsfreeze():
        log("fsfreeze not available — skipping")
        return 0

    if not acquire_lock():
        return 0

    try:
        log("Freezing filesystems")

        for mp in FREEZE_TARGETS:
            freeze_mount(mp)

        time.sleep(FREEZE_HOLD_SECONDS)

        log("Unfreezing filesystems")

        for mp in FREEZE_TARGETS:
            unfreeze_mount(mp)

    finally:
        release_lock()

    return 0


if __name__ == "__main__":
    sys.exit(main())